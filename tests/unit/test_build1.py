import osimport Queueimport ConfigParserimport copyfrom oslo_config import cfgfrom oslo_config import fixtureimport mockimport siximport testtoolsfrom kolla.cmd import buildfrom kolla.common.config import parsefrom requests import exceptions as requests_expclass TestKollaWorker(testtools.TestCase):    def setUp(self):        super(TestKollaWorker, self).setUp()        config = {            'namespace': 'kolla-test',            'base': 'ubuntu',            'base_tag': 'latest',            'install_type': 'source',            'tag': 'letest',            'include_header': '',            'include_footer': '',            'regex': ''        }        self.conf = cfg.CONF        from kolla.common.config import _PROFILE_OPTS, _BASE_OPTS, _CLI_OPTS        self.conf.register_opts(_CLI_OPTS)        self.conf.register_opts(_BASE_OPTS)        self.conf.register_opts(_PROFILE_OPTS)        self.kolla = build.KollaWorker(self.conf)    @mock.patch('datetime.datetime')    def test_setup_working_dir(self, datetime_mock):        prefix = 'kolla-'        ts = '2015-10-19_22-22-22_'        def create_copytree():            def copytree(src, dst):                self.assertIn(prefix + ts, dst)            return copytree        with mock.patch('shutil.copytree', new_callable=create_copytree):            local_time_mock = mock.MagicMock()            local_time_mock.strftime.return_value = ts            datetime_mock.fromtimestamp.return_value = local_time_mock            self.kolla.setup_working_dir()    @mock.patch('os.walk')    def test_set_time(self, os_walk):        self.kolla.working_dir = '/tmp'        self.all_file_list = None        os_walk.return_value = [('docker/ironic',                                 ['ironic-base',                                  'ironic-discoverd'],                                 []),                                ('docker/ironic/ironic-base',                                 [],                                 ['Dockerfile.j2', 'Dockerfile'])]        def list_all_file():            ret = []            for root, dirs, files in os_walk.return_value:                for file_ in files:                    ret.append(os.path.join(root, file_))                for dir_ in dirs:                    ret.append(os.path.join(root, dir_))            return ret        def create_utime():            self.all_file_list = list_all_file()            def utime_side_effect(path, times):                self.assertEqual((0, 0), times)                self.assertIn(path, self.all_file_list)                self.all_file_list.pop(self.all_file_list.index(path))            return utime_side_effect        with mock.patch('os.utime', new_callable=create_utime):            self.kolla.set_time()            self.assertEqual(0, len(self.all_file_list))    @mock.patch('shutil.rmtree')    def test_cleanup(self, rmtree):        self.kolla.temp_dir = mock.MagicMock()        self.kolla.cleanup()        rmtree.assert_called_once_with(self.kolla.temp_dir)    def test_fileter_images(self):        self.iamges = []        self.regex = []    def test_build_image_list(self):        self.kolla.docker_build_paths = ['glance-api', 'glance-base', 'base']        expepcted_value = [            {'name': 'glance-api', 'path': 'glance-api', 'fullname': 'kollaglue/centos-binary-glance-api:2.0.0',             'parent_name': 'kollaglue/centos-binary-glance-base:2.0.0'},            {'name': 'glance-base', 'path': 'glance-base', 'fullname': 'kollaglue/centos-binary-glance-base:2.0.0',             'parent_name': 'kollaglue/centos-binary-openstack-base:2.0.0'},            {'name': 'base', 'path': 'base', 'fullname': 'kollaglue/centos-binary-base:2.0.0',             'parent_name': 'centos:latest', 'parent': None,}        ]        self.kolla.base = 'centos'        self.kolla.install_type = 'binary'        self.kolla.namespace = 'kollaglue'        self.kolla.image_prefix = self.kolla.base + '-' + self.kolla.install_type + '-'        content_map = {            'glance-api/Dockerfile': 'FROM kollaglue/centos-binary-glance-base:2.0.0\n\n',            'glance-base/Dockerfile': 'FROM kollaglue/centos-binary-openstack-base:2.0.0\n\n',            'base/Dockerfile': 'FROM centos:latest\n\n',        }        def mock_open(content_map):            open_mock = mock.MagicMock()            def custom_open(name, mode='r'):                file_mock = mock.MagicMock()                file_mock.__enter__.return_value = file_mock                def custom_read():                    return content_map[name]                file_mock.read.side_effect = custom_read                return file_mock            open_mock.side_effect = custom_open            return open_mock        with mock.patch('kolla.cmd.build.open', mock_open(content_map)):            self.kolla.build_image_list()        for index, image in enumerate(self.kolla.images):            self.assertEquals('unprocessed', image['status'])            self.assertEquals([], image['children'])            for key in expepcted_value[index]:                self.assertEquals(expepcted_value[index][key], image[key])    def test_find_parents(self):        base_image = {            'fullname': 'kollaglue/centos-binary-base:latest',            'parent_name': 'centos',            'children': [],            'parent': None,        }        openstack_base_image = {            'fullname': 'kollaglue/centos-binary-openstack-base:latest',            'parent_name': 'kollaglue/centos-binary-base:latest',            'children': [],        }        cinder_api_image = {            'fullname': 'kollaglue/centos-binary-cinder-api:latest',            'parent_name': 'kollaglue/centos-binary-openstack-base:latest',            'children': [],        }        images = [base_image, openstack_base_image, cinder_api_image]        exepected_base_image = base_image.copy()        exepected_base_image.update({            'children': [openstack_base_image],            'parent': None,        })        exepected_openstack_base_image = openstack_base_image.copy()        exepected_openstack_base_image.update({            'children': [cinder_api_image],            'parent': base_image,        })        exepected_cinder_api_image = cinder_api_image.copy()        exepected_cinder_api_image.update({            'children': [],            'parent': openstack_base_image,        })        expected_images = [exepected_base_image, exepected_openstack_base_image,                           exepected_cinder_api_image]        self.kolla.images = images        self.kolla.find_parents()        self.assertEquals(expected_images, self.kolla.images)    @mock.patch('kolla.cmd.build.KollaWorker.build_image_list')    @mock.patch('kolla.cmd.build.KollaWorker.find_parents')    @mock.patch('kolla.cmd.build.KollaWorker.filter_images')    def test_build_queue(self, *args):        base_image = {            'name': 'base',            'fullname': 'kollaglue/centos-binary-base:latest',            'parent_name': 'centos',            'parent': None,        }        openstack_base_image = {            'name': 'openstack-base',            'fullname': 'kollaglue/centos-binary-openstack-base:latest',            'parent_name': 'kollaglue/centos-binary-base:latest',            'parent': base_image,        }        data_image = {            'name': 'data',            'fullname': 'kollaglue/centos-binary-data:latest',            'parent_name': 'centos',            'parent': None,        }        self.kolla.images = [base_image, openstack_base_image, data_image]        queue = self.kolla.build_queue()        for name in ['base', 'data']:            self.assertEquals(name, queue.get().get('name'))class TestFunction(testtools.TestCase):    def setUp(self):        super(TestFunction, self).setUp()        self.conf = cfg.ConfigOpts()        from kolla.common.config import _BASE_OPTS, _CLI_OPTS, _PROFILE_OPTS        self.conf.register_opts(_BASE_OPTS)        self.conf.register_opts(_CLI_OPTS)        self.conf.register_opts(_PROFILE_OPTS)        self.kolla = build.KollaWorker(self.conf)    @mock.patch('kolla.cmd.build.docker.utils.kwargs_from_env')    @mock.patch('kolla.cmd.build.docker.Client')    def test_push_images_failed(self, docker_client, kwargs_from_env):        kwargs_from_env.return_value = {}        def push_image(*args, **kwargs):            yield "{u'status': u'The push refers to a repository [docker.io/library/ubuntu] (len: 1)'}"            yield "{u'status': u'Image already exists', u'progressDetail': {}, u'id': u'e9ae3c220b23'}"            yield "{u'errorDetail': {u'message': u'unauthorized: access to the requested resource is not authorized'}, u'error': u'unauthorized: access to the requested resource is not authorized'}"        dc = mock.MagicMock()        docker_client.return_value = dc        dc.push_image = push_image        image = {'fullname': 'base', 'logs': '',}class TestWorkerThread(testtools.TestCase):    def setUp(self):        super(TestWorkerThread, self).setUp()        self.queue = mock.MagicMock()        config = {            'no_cache': True,            'cache': False,            'keep': True,            'retries': 3,        }        self.conf = cfg.CONF        from kolla.common.config import _PROFILE_OPTS, _BASE_OPTS, _CLI_OPTS        self.conf.register_opts(_CLI_OPTS)        self.conf.register_opts(_BASE_OPTS)        self.conf.register_opts(_PROFILE_OPTS)    @mock.patch("kolla.cmd.build.docker")    @mock.patch("kolla.cmd.build.WorkerThread.end_task")    @mock.patch("kolla.cmd.build.WorkerThread.builder")    def test_run(self, builder, end_task, docker):        class Action(object):            def __init__(self, images):                self.images = images                self.index = 0            def get(self):                image = self.images[self.index]['image']                self.index += 1                return image            def builder(self, image):                for i in self.images:                    if image is i['image']:                        action_list = i['action']                        break                action = action_list.pop(0)                if action == 'exception':                    raise Exception('error')                elif action in ['built', 'unmatched', 'parent_error']:                    image['status'] = action        def get_init_image():            return {'status': 'ok',}        images = [            {                'image': get_init_image(),                'action': ['built'],            },            {                'image': get_init_image(),                'action': ['unmatched'],            },            {                'image': get_init_image(),                'action': ['parent_error'],            },            {                'image': get_init_image(),                'action': ['failed', 'built'],            },            {                'image': get_init_image(),                'action': ['exception'],            }        ]        action = Action(images)        queue = mock.MagicMock()        push_queue = mock.MagicMock()        queue.get.side_effect = action.get        builder.side_effect = action.builder        worker_thread = build.WorkerThread(queue, push_queue, self.conf)        worker_thread.run()        for i in images:            self.assertEqual(0, len(i['action']), 'failed in %s' % i)    @mock.patch("kolla.cmd.build.docker")    def test_end_task(self, docker):        queue = mock.MagicMock()        push_queue = mock.MagicMock()        worker_thread = build.WorkerThread(queue, push_queue, self.conf)        image = {            'name': 'base',            'children': [                {'name': 'child1',},                {'name': 'child2',},                {'name': 'child3',}            ],        }        worker_thread.end_task(image)        queue.task_done.assert_called_once_with()        self.assertEqual([mock.call(i) for i in image['children']],                         queue.put.call_args_list)    @mock.patch("kolla.cmd.build.docker")    def test_builder_unmatched(self, docker):        queue = mock.MagicMock()        push_queue = mock.MagicMock()        image = {'status': 'unmatched', 'name': 'base',}        worker_thread = build.WorkerThread(queue, push_queue, self.conf)        worker_thread.builder(image)        self.assertEqual('unmatched', image['status'])    @mock.patch("kolla.cmd.build.docker")    def test_builder_parent_error(self, docker):        queue = mock.MagicMock()        push_queue = mock.MagicMock()        worker_thread = build.WorkerThread(queue, push_queue, self.conf)        image = {'status': 'unprocessed', 'name': 'base', 'parent':            {'status': 'error',},}        worker_thread.builder(image)        self.assertEqual('parent_error', image['status'])        image = {'status': 'unprocessed', 'name': 'base', 'parent':            {'status': 'parent_error',},}        worker_thread.builder(image)        self.assertEqual('parent_error', image['status'])        image = {'status': 'unprocessed', 'name': 'base', 'parent':            {'status': 'connection_error',},}        worker_thread.builder(image)        self.assertEqual('parent_error', image['status'])    @mock.patch("kolla.cmd.build.WorkerThread.process_source")    @mock.patch("kolla.cmd.build.docker")    def test_builder_source_error(self, docker, process_soruce):        queue = mock.MagicMock()        push_queue = mock.MagicMock()        worker_thread = build.WorkerThread(queue, push_queue, self.conf)        image = {'status': 'unprocessed', 'name': 'base', 'source':            {'source': '',}, 'parent': None,}        def process_soruce_mock(image, source):            image['status'] = 'error'        process_soruce.side_effect = process_soruce_mock        worker_thread.builder(image)        self.assertEquals('error', image['status'])    def init_process_reource(self, requests):        image = {'path': '/a', 'name': 'horizon'}        source = {'type': 'url', 'name': 'horizon', 'source': 'horizon_source'}        queue = mock.MagicMock()        push_queue = mock.MagicMock()        worker_thread = build.WorkerThread(queue, push_queue, self.conf)        return image, source, worker_thread    @mock.patch("kolla.cmd.build.os.utime")    @mock.patch("kolla.cmd.build.tarfile")    @mock.patch("kolla.cmd.build.shutil")    @mock.patch("kolla.cmd.build.git")    @mock.patch("kolla.cmd.build.requests")    def test_process_source_url(self, requests, git, shutil, tarfile, utime):        image, source, worker_thread = self.init_process_reource(requests)        open_mock = mock.MagicMock()        response = mock.MagicMock()        response.status_code = 200        response.content = "abc"        requests.get.return_value = response        with mock.patch('kolla.cmd.build.open', open_mock):            dest_archive = worker_thread.process_source(image, source)        self.assertEqual(dest_archive, '/a/horizon-archive')        open_mock().__enter__.return_value.write.assert_called_once_with(response.content)        utime.assert_called_once_with(dest_archive, (0, 0))    @mock.patch("kolla.cmd.build.os.utime")    @mock.patch("kolla.cmd.build.tarfile")    @mock.patch("kolla.cmd.build.shutil")    @mock.patch("kolla.cmd.build.git")    @mock.patch("kolla.cmd.build.requests")    def test_process_source_url_invalid_code(self, requests, git, shutil, tarfile, utime):        image, source, worker_thread = self.init_process_reource(requests)        response = mock.MagicMock()        response.status_code = 500        requests.get.return_value = response        worker_thread.process_source(image, source)        self.assertEqual('error', image['status'])    @mock.patch("kolla.cmd.build.os.utime")    @mock.patch("kolla.cmd.build.tarfile")    @mock.patch("kolla.cmd.build.shutil")    @mock.patch("kolla.cmd.build.git")    @mock.patch("kolla.cmd.build.requests")    def test_process_source_url_timeout(self, requests, git, shutil, tarfile, utime):        image, source, worker_thread = self.init_process_reource(requests)        requests.get.side_effect = requests_exp.Timeout('timeout')        worker_thread.process_source(image, source)        self.assertEqual('error', image['status'])    @mock.patch("kolla.cmd.build.os.utime")    @mock.patch("kolla.cmd.build.tarfile")    @mock.patch("kolla.cmd.build.shutil")    @mock.patch("kolla.cmd.build.git")    def test_process_source_git(self, git, shutil, tarfile, utime):        image = {'path': '/a', 'name': 'horizon'}        source = {'type': 'url', 'name': 'horizon', 'source': 'horizon_source', 'reference': 'master'}        queue = mock.MagicMock()        push_queue = mock.MagicMock()        worker_thread = build.WorkerThread(queue, push_queue, self.conf)        source['type'] = 'git'        dest_archive = worker_thread.process_source(image, source)        expected_git_args_list = [mock.call(),                                  mock.call('/a/horizon-archive-master')]        self.assertEquals(expected_git_args_list, git.Git.call_args_list)        git.Git().checkout.assert_called_once_with('master')        tarfile.open.assert_called_once_with(dest_archive, 'w')        tarfile.open().__enter__.return_value.add.assert_called_once_with(            '/a/horizon-archive-master', arcname='horizon-archive-master')        utime.assert_called_once_with('/a/horizon-archive', (0, 0))    @mock.patch("kolla.cmd.build.os.utime")    @mock.patch("kolla.cmd.build.tarfile")    @mock.patch("kolla.cmd.build.shutil")    @mock.patch("kolla.cmd.build.git")    def test_process_source_git_error(self, git, shutil, tarfile, utime):        image = {'path': '/a', 'name': 'horizon'}        source = {'type': 'url', 'name': 'horizon', 'source': 'horizon_source', 'reference': 'master'}        queue = mock.MagicMock()        push_queue = mock.MagicMock()        worker_thread = build.WorkerThread(queue, push_queue, self.conf)        source['type'] = 'git'        git.Git.side_effect = Exception("git error")        worker_thread.process_source(image, source)        self.assertEqual(image['status'], 'error')